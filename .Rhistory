#If data starts decreasing more than
# well_data_normal <- subset(well_data_normal, Cycle < 36)
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing more than
# well_data_normal <- subset(well_data_normal, Cycle < 36)
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
dropped
max(well_data_normal$Cycle)
max(well_data$Cycle)
?has_error
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, error = function(err) {
NA
}, silent = TRUE)
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
?try
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
tryCatch({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, silent = TRUE)
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
try({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, silent = TRUE)
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
invisible({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, silent = TRUE)
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
invisible({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
})
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
library(nlme)
library(testit)
df <- data.frame(read.table('df3.csv',sep=',', header=TRUE, row.names = 1))
for (well in unique(df$Well))
{
if(well != "E10"){
next
}
well_data <- subset(df, Well == well)
print(well)
well_data$RFU = well_data$RFU - min(well_data$RFU) + 1
well_data_normal <- well_data
well_data_normal$RFU <- well_data_normal$RFU / max(well_data_normal$RFU)
#If data starts decreasing near the end of a reaction, interferes with logistic fit. To fix,
#dropped successively more points until fit works
# well_data_normal <- subset(well_data_normal, Cycle < 36)
try({
dropped = 0
while(has_error(nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)) &
dropped < length(well_data_normal$C)){
well_data_normal <- subset(well_data_normal, Cycle < max(well_data_normal$Cycle) - dropped)
dropped = dropped + 1
}
}, silent = TRUE)
fitted <- nls(RFU ~ SSlogis(Cycle, Asym, xmid, scal), data = well_data_normal, trace = TRUE)
y_h <- SSlogis(well_data_normal$Cycle, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3])
well_data_fit <- well_data_normal
well_data_fit$RFU <- y_h
xmid <- summary(fitted)$coefficients[2]
print(xmid)
TTR <- data.frame(Cycle = xmid, RFU = SSlogis(xmid, summary(fitted)$coefficients[1], summary(fitted)$coefficients[2],
summary(fitted)$coefficients[3]) )
p1 <- ggplot(data = well_data, aes(x = Cycle, y = RFU)) +
geom_line(data = well_data, aes(color = 'data')) +
geom_line(data = well_data_fit, aes(y = RFU *max(well_data$RFU), color='fit')) +
geom_point(data = TTR, aes(y = RFU * max(well_data$RFU), color = 'TTR')) +
labs(title = well)
print(p1)
}
?try
?options
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?downloadHandler
shiny::runApp()
shiny::runApp()
?downloadHandler
shiny::runApp()
